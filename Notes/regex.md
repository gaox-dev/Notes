---
title: Javascript正则表达式
date: 2022-04-15 17:13:47
tags: 正则, regex
---


# 正则表达式

## 1. 描述字符

根据正则表达式语法规则，大部分字符仅能够描述自身，这些字符被称为`普通字符`，如所有的字母、数字等。

`元字符`就是拥有特动功能的特殊字符，大部分需要加`反斜杠`进行标识，以便于普通字符进行区别，而少数元字符，需要加反斜杠，以便转译为普通字符使用。JavaScript 正则表达式支持的元字符如表所示。

| 元字符 | 描述                                   |
| ------ | -------------------------------------- |
| .      | 查找单个字符，除了换行和行结束符       |
| \w     | 查找单词字符                           |
| \W     | 查找非单词字符                         |
| \d     | 查找数字                               |
| \D     | 查找非数字字符                         |
| \s     | 查找空白字符                           |
| \S     | 查找非空白字符                         |
| \b     | 匹配单词边界                           |
| \B     | 匹配非单词边界                         |
| \0     | 查找 NUL字符                           |
| \n     | 查找换行符                             |
| \f     | 查找换页符                             |
| \r     | 查找回车符                             |
| \t     | 查找制表符                             |
| \v     | 查找垂直制表符                         |
| \xxx   | 查找以八进制数 xxxx 规定的字符         |
| \xdd   | 查找以十六进制数 dd 规定的字符         |
| \uxxxx | 查找以十六进制 xxxx规定的 Unicode 字符 |

## 2. 转义，特殊字符

记一下几个需要转义的正则表达式字符

| 字符 | 用途                                                         |
| :--- | :----------------------------------------------------------- |
| $    | 匹配输入字符串的结尾位置                                     |
| ( )  | 标记一个子表达式的开始和结束位置                             |
| *    | 匹配前面的子表达式零次或多次                                 |
| +    | 匹配前面的子表达式一次或多次                                 |
| .    | 匹配除换行符 \n之外的任何单字符                              |
| [ ]  | 标记一个中括号表达式的开始                                   |
| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符         |
| \    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 |
| ^    | 匹配输入字符串的开始位置，在【^】表示取反                    |
| { }  | 标记限定符表达式的开始                                       |
| \|   | 指明两项之间的一个选择                                       |

## 3. 描述字符范围

在正则表达式语法中，放括号表示字符范围。在方括号中可以包含多个字符，表示匹配其中任意一个字符。如果多个字符的编码顺序是连续的，可以仅指定开头和结尾字符，省略中间字符，仅使用连字符`~`表示。如果在方括号内添加脱字符`^`前缀，还可以表示范围之外的字符。例如：

- [abc]：查找方括号内任意一个字符。
- [^abc]：查找不在方括号内的字符。
- [0-9]：查找从 0 至 9 范围内的数字，即查找数字。
- [a-z]：查找从小写 a 到小写 z 范围内的字符，即查找小写字母。
- [A-Z]：查找从大写 A 到大写 Z 范围内的字符，即查找大写字母。
- [A-z]：查找从大写 A 到小写 z 范围内的字符，即所有大小写的字母。



## 4. 重复匹配

在正则表达式语法中，定义了一组重复类量词，如表所示。它们定义了重复匹配字符的确数或约数。



| 量词   | 描述                                          |
| ------ | --------------------------------------------- |
| n+     | 匹配任何包含至少一个 n 的字符串               |
| n*     | 匹配任何包含零个或多个 n 的字符串             |
| n?     | 匹配任何包含零个或一个 n 的字符串             |
| n{x}   | 匹配包含 x 个 n 的序列的字符串                |
| n{x,y} | 匹配包含最少 x 个、最多 y 个 n 的序列的字符串 |
| n{x,}  | 匹配包含至少 x 个 n 的序列的字符串            |

## 5. 惰性匹配

重复类量词都具有贪婪性，在条件允许的前提下，会匹配尽可能多的字符。

- ?、{n} 和 {n,m} 重复类具有弱贪婪性，表现为贪婪的有限性。
- *、+ 和 {n,} 重复类具有强贪婪性，表现为贪婪的无限性。

针对 6 种重复类惰性匹配的简单描述如下：

- {n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。
- {n}?：尽量匹配 n 次。
- {n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。
- ??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。
- +?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。
- *? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。

## 6. 前向查找

### 正向查找

指定匹配模式后面的字符必须被匹配，但又不返回这些字符，（找到这里的位置）。语法格式如下：

匹配模式 (?= 匹配条件)

声明包含在小括号内，它不是分组，因此作为子表达式。

下面代码定义一个正前向生命的匹配模式。

```js
var s = "one:1;two=2";
var r = /\w*(?==)/;  //使用正前向声明，指定执行匹配必须满足的条件
var a = s.match(r);  //返回数组["two"]
```

在上面示例中，通过`?==`锚定条件，指定只有在 \w* 所能够匹配的字符后面跟随一个等号字符，才能够执行 \w* 匹配。所以，最后匹配的字符串“two”，而不是字符串“one”。

### 前向负查找

与正向声明匹配相反，指定接下来的字符都不必被匹配。语法格式如下：

匹配模式(?! 匹配条件)


下面代码定义一个反前向生命的匹配模式。

```js
var s = "one:1;two=2";
var r = /\w*(?!=)/;  //使用正前向声明，指定执行匹配不必满足的条件
var a = s.match(r);  //返回数组["one"]
```

在上面示例中，通过`?!=`锚定条件，指定只有在“\w*”所能够匹配的字符后面不跟随一个等号字符，才能够执行 \w*匹配。所以，最后匹配的是字符串“one”，而不是字符串“two”。

### 后项查找

```js
var s = "<h1>title</h1>";
var r = /(?<=<h1>).*/;   
var a = s.match(r);      //返回数组['title</h1>']
```

### 后向负查找

```js
var s = "<h1>title</h1>";
var r = /(?<!<h1>)\w*/;   
var a = s.match(r);     //返回[]
```



| 回溯查找   | 正则                   | 记忆方式                                                     |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 引用       | \0,\1,\2 和 $0, $1, $2 | 转义+数字                                                    |
| 非捕获组   | (?:)                   | 引用表达式(()), 本身不被消费(?),引用(:)                      |
| 前向查找   | (?=)                   | 引用子表达式(())，本身不被消费(?), 正向的查找(=)             |
| 前向负查找 | (?!)                   | 引用子表达式(())，本身不被消费(?), 负向的查找(!)             |
| 后向查找   | (?<=)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=) |
| 后向负查找 | (?<!)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!) |



# 常用正则表达式

```js
// 1.版本号x.y.z
let versionRegex = /^(?:\d+\.){2}\d+$/

// 2.大于等于0, 小于等于150, 支持小数位出现5
let pointRegex = /^(?:[1-9]?\d|1[0-4]\d)(?:.5)?$|150/

// 3.匹配所有页面内元素的id名称
const idRegexp = /id="([^"]+)"/g
document.body.innerHTML
  .match(idRegexp)
  .map((idStr) => idStr.replace(idRegexp, '$1'))

// 4. windows下的文件夹和文件路径
const windowsPathRegex = /^[a-zA-Z]:\\(?:[^\\:*<>|"?\r\n/]+\\?)*(?:(?:[^\\:*<>|"?\r\n/]+)\.\w+)?$/;

// 5.手机号
const mobileRegex = /^(?:\+?86)?1(?:3\d{3}|5[^4\D]\d{2}|8\d{3}|7(?:[235-8]\d{2}|4(?:0\d|1[0-2]|9\d))|9[0-35-9]\d{2}|66\d{2})\d{6}$/

// 6.是否中文
const checkChineseRegex = /^[\u4E00-\u9FA5]+$/

// 7.url是否是http或者https协议头
const checkProtocolRegex = /^https?:/

// 8.16进制颜色
const matchColorRegex = /#(?:[\da-fA-F]{6}|[\da-fA-F]{3})/g

// 9.时间日期格式
const checkDateRegex = /^\d{4}(-\.\/)(?:0[1-9]|1[02])\1(?:0[1-9]|[12]\d|3[01])$/

// 10.24小时制时间
const check24TimeRegex = /^(?:(?:0?|1)\d|2[0-3]):(?:0?|[1-5])\d$/

// 11.将字符串驼峰化
const camelCase = (string) => {
  const camelCaseRegex = /[-_\s]+(.)?/g
  return string.replace(camelCaseRegex, (match, char) => {
    return char ? char.toUpperCase() : ''
  })
}

// 12. 字符串首字母大写，剩下的小写
const capitalize = (string) => {
  const capitalizeRegex = /(?:^|\s+)\w/g
  return string.toLowerCase().replace(capitalizeRegex, (match) => match.toUpperCase())
}

// 13.HTML转义
const escape = (string) => {
  const escapeMaps = {
  '&':'amp',
  '<':'lt',
  '>':'gt',
  '"':'quot',
  "'":'#39',
}
	const escapeRegexp = new RegExp(`[${Object.keys(escapeMaps).join('')}]`, 'g')
	return string.replace(escapeRegexp, (match) => `&${escapeMaps[match]};`)
}
// 14.HTML反转义
const unescape = (string) => {
  const unescapeMaps = {
    'amp': '&',
    'lt': '<',
    'gt': '>',
    'quot': '"',
    '#39': "'"
  }
  const unescapeRegexp = /&([^;]+);/g
  return string.replace(unescapeRegexp, (match, unescapeKey) => {
    return unescapeMaps[ unescapeKey ] || match
  })
}

// 15.数字价格千分位分割
const thousandRegex = /(?!^)(?=(\d{3})+$)/g
'123456789'.replace(thousandRegex, ',')

// 16.手机号3-4-4分割
let mobileReg = /(?=(\d{4})+$)/g 
'18379836654'.replace(mobileReg, "-")

// 17.手机号3-4-4分割扩展
const formatMobile = (mobile) => {
  return String(mobile).slice(0,11)
      .replace(/(?<=\d{3})\d+/, ($0) => '-' + $0)
      .replace(/(?<=[\d-]{8})\d{1,4}/, ($0) => '-' + $0)
}

// 18.验证密码的合法性,密码长度是6-12位，由数字、小写字母和大写字母组成，但必须至少包括2种字符
let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])^[a-zA-Z\d]{6,12}$/

// 19.实现一个trim函数
const trim = (str) => {
  return str.replace(/^\s*|\s*$/g, '');
}

// 20.去掉所有的空格
const reg = (str) => {
 return str.replace(/\s/g, '');
}
```





